<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Save the Doge</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; touch-action: none; user-select: none; }
        
        /* UI OVERLAYS */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; align-items: center; }
        
        #timer-container { 
            margin-top: 20px; width: 300px; height: 20px; background: rgba(0,0,0,0.3); 
            border-radius: 10px; overflow: hidden; border: 2px solid white; display: none;
        }
        #timer-bar { width: 100%; height: 100%; background: #f1c40f; transition: width 0.1s linear; }
        
        #level-text { margin-top: 10px; color: white; font-weight: bold; font-size: 20px; text-shadow: 1px 1px 0 #000; }
        
        #modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: white; padding: 30px; border-radius: 20px; text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3); pointer-events: auto; display: none;
        }
        #modal h1 { margin: 0 0 10px 0; font-size: 40px; }
        #modal p { margin: 0 0 20px 0; color: #555; }
        
        button {
            padding: 15px 40px; font-size: 20px; border: none; border-radius: 50px;
            color: white; font-weight: bold; cursor: pointer; box-shadow: 0 4px 0 rgba(0,0,0,0.2);
            transition: transform 0.1s;
        }
        button:active { transform: translateY(4px); box-shadow: none; }
        .btn-next { background: #2ecc71; }
        .btn-retry { background: #e74c3c; }

        #hint {
            position: absolute; bottom: 50px; background: rgba(255,255,255,0.8);
            padding: 10px 20px; border-radius: 20px; font-weight: bold; color: #333;
            animation: bounce 2s infinite; pointer-events: none;
        }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="level-text">Level 1</div>
        <div id="timer-container"><div id="timer-bar"></div></div>
        <div id="hint">ðŸ‘‡ Draw to Protect!</div>

        <div id="modal">
            <h1 id="modal-title">You Won!</h1>
            <p id="modal-msg">The Doge is safe.</p>
            <button id="modal-btn" class="btn-next" onclick="nextLevel()">Next Level</button>
        </div>
    </div>

<script>
    // --- PHYSICS ENGINE SETUP ---
    const Engine = Matter.Engine,
          Render = Matter.Render,
          Runner = Matter.Runner,
          Composite = Matter.Composite,
          Bodies = Matter.Bodies,
          Body = Matter.Body,
          Events = Matter.Events,
          Vector = Matter.Vector;

    const engine = Engine.create();
    const world = engine.world;

    // Renderer
    const render = Render.create({
        element: document.body,
        engine: engine,
        options: {
            width: window.innerWidth,
            height: window.innerHeight,
            wireframes: false, // Important for colors/emojis
            background: 'transparent'
        }
    });

    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

    // --- GAME VARIABLES ---
    let currentLevel = 1;
    let isDrawing = false;
    let hasStarted = false; // Physics paused until draw finishes
    let gameOver = false;
    let drawPoints = [];
    let timeLeft = 10;
    let timerInterval;
    
    // Entities
    let doge, hive;
    let bees = [];
    let lines = [];
    
    // Config
    const W = window.innerWidth;
    const H = window.innerHeight;

    // --- LEVEL DESIGNS ---
    // Coordinates are percentages (0.5 = 50% width)
    const levels = {
        1: { 
            dog: {x: 0.5, y: 0.8}, 
            hive: {x: 0.5, y: 0.2},
            walls: [ 
                {x: 0.5, y: 1.0, w: 1.0, h: 0.1} // Ground
            ] 
        },
        2: { 
            dog: {x: 0.2, y: 0.6}, 
            hive: {x: 0.8, y: 0.2},
            walls: [ 
                {x: 0.2, y: 0.7, w: 0.3, h: 0.05} // Floating Platform
            ] 
        },
        3: { 
            dog: {x: 0.5, y: 0.5}, 
            hive: {x: 0.5, y: 0.15},
            walls: [ 
                {x: 0.4, y: 0.6, w: 0.4, h: 0.05, angle: 0.3}, // Slope 1
                {x: 0.6, y: 0.6, w: 0.4, h: 0.05, angle: -0.3} // Slope 2
            ] 
        }
    };

    // --- CORE FUNCTIONS ---

    function initLevel(lvl) {
        // Reset State
        Composite.clear(world);
        engine.events = {}; 
        bees = [];
        lines = [];
        drawPoints = [];
        isDrawing = false;
        hasStarted = false;
        gameOver = false;
        timeLeft = 10;
        
        // UI Reset
        document.getElementById('modal').style.display = 'none';
        document.getElementById('timer-container').style.display = 'none';
        document.getElementById('timer-bar').style.width = '100%';
        document.getElementById('hint').style.display = 'block';
        document.getElementById('level-text').innerText = "Level " + lvl;
        
        // Load Level Data
        const data = levels[lvl] || levels[1];

        // Create Walls
        data.walls.forEach(w => {
            const wall = Bodies.rectangle(w.x * W, w.y * H, w.w * W, w.h * H, { 
                isStatic: true, 
                angle: w.angle || 0,
                render: { fillStyle: '#27ae60' } 
            });
            Composite.add(world, wall);
        });

        // Invisible Bounds (Left/Right/Top) to keep doge in
        const bounds = [
            Bodies.rectangle(-25, H/2, 50, H, { isStatic: true, render: { visible: false } }),
            Bodies.rectangle(W+25, H/2, 50, H, { isStatic: true, render: { visible: false } }),
        ];
        Composite.add(world, bounds);

        // Create Doge
        doge = Bodies.circle(data.dog.x * W, data.dog.y * H, 25, {
            restitution: 0.5,
            label: "Doge",
            render: { fillStyle: 'transparent' } // Emoji overlay handled in render loop
        });
        Composite.add(world, doge);

        // Set Hive Pos
        hive = { x: data.hive.x * W, y: data.hive.y * H };

        // Freeze physics initially (gravity off)
        engine.gravity.y = 0;
    }

    // --- INPUT HANDLING (DRAWING) ---
    
    function startDraw(e) {
        if(hasStarted || gameOver) return;
        isDrawing = true;
        
        const pos = getPos(e);
        drawPoints.push(pos);
    }

    function moveDraw(e) {
        if(!isDrawing) return;
        const pos = getPos(e);
        
        // Don't add points too close together
        const last = drawPoints[drawPoints.length - 1];
        const dist = Math.hypot(pos.x - last.x, pos.y - last.y);
        
        if(dist > 15) {
            drawPoints.push(pos);
            // Visual feedback (Temporary line)
            const ctx = render.context;
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';
            ctx.strokeStyle = '#333';
            ctx.beginPath();
            ctx.moveTo(last.x, last.y);
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
        }
    }

    function endDraw() {
        if(!isDrawing) return;
        isDrawing = false;
        
        if(drawPoints.length > 2) {
            createPhysicsLine();
            startSurvivalPhase();
        }
    }

    function getPos(e) {
        return {
            x: e.touches ? e.touches[0].clientX : e.clientX,
            y: e.touches ? e.touches[0].clientY : e.clientY
        };
    }

    // Convert drawn points to solid physics body
    function createPhysicsLine() {
        const parts = [];
        
        for(let i=0; i<drawPoints.length-1; i++) {
            const p1 = drawPoints[i];
            const p2 = drawPoints[i+1];
            
            const cx = (p1.x + p2.x) / 2;
            const cy = (p1.y + p2.y) / 2;
            const len = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);

            const rect = Bodies.rectangle(cx, cy, len, 10, {
                angle: angle,
                render: { fillStyle: '#333' }
            });
            parts.push(rect);
        }

        const compound = Body.create({
            parts: parts,
            friction: 1.0,  // High friction to stick to walls
            restitution: 0.1,
            density: 0.005  // Heavy enough to push bees
        });

        Composite.add(world, compound);
    }

    // --- GAME LOOP ---

    function startSurvivalPhase() {
        hasStarted = true;
        document.getElementById('hint').style.display = 'none';
        document.getElementById('timer-container').style.display = 'block';
        
        // Turn Gravity ON
        engine.gravity.y = 1;

        // Timer Logic
        timerInterval = setInterval(() => {
            if(gameOver) return;
            timeLeft -= 0.1;
            document.getElementById('timer-bar').style.width = (timeLeft * 10) + "%";
            
            if(timeLeft <= 0) winGame();
        }, 100);

        // Spawn Bees Logic
        let beeCount = 0;
        const beeSpawner = setInterval(() => {
            if(gameOver || timeLeft <= 0 || beeCount > 30) {
                clearInterval(beeSpawner); return;
            }
            spawnBee();
            beeCount++;
        }, 400); // Fast spawn rate
    }

    function spawnBee() {
        const bee = Bodies.circle(hive.x, hive.y, 10, {
            restitution: 0.8,
            frictionAir: 0,
            label: "Bee",
            render: { fillStyle: 'transparent' } 
        });
        
        // Initial push towards dog
        const force = Vector.sub(doge.position, hive);
        const norm = Vector.normalise(force);
        Body.applyForce(bee, bee.position, Vector.mult(norm, 0.002));
        
        bees.push(bee);
        Composite.add(world, bee);
    }

    // Rendering & Physics Updates
    Events.on(render, 'afterRender', () => {
        const ctx = render.context;
        
        // Draw Emojis on top of physics bodies
        ctx.font = "30px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // Doge
        ctx.save();
        ctx.translate(doge.position.x, doge.position.y);
        ctx.rotate(doge.angle);
        ctx.fillText(gameOver ? (timeLeft<=0 ? "ðŸ˜Ž":"ðŸ˜µ") : "ðŸ¶", 0, 0);
        ctx.restore();

        // Bees
        ctx.font = "20px Arial";
        bees.forEach(b => {
            ctx.save();
            ctx.translate(b.position.x, b.position.y);
            ctx.fillText("ðŸ", 0, 0);
            ctx.restore();
            
            // Homing Logic (Move towards dog every frame)
            if(!gameOver) {
                const dir = Vector.sub(doge.position, b.position);
                const norm = Vector.normalise(dir);
                Body.applyForce(b, b.position, Vector.mult(norm, 0.00004));
            }
        });

        // Hive
        ctx.font = "50px Arial";
        ctx.fillText("ðŸª¹", hive.x, hive.y);
    });

    // Collision Detection
    Events.on(engine, 'collisionStart', (event) => {
        if(gameOver) return;
        
        event.pairs.forEach(pair => {
            const A = pair.bodyA.label;
            const B = pair.bodyB.label;
            
            // If Bee touches Doge
            if((A === 'Doge' && B === 'Bee') || (B === 'Doge' && A === 'Bee')) {
                loseGame();
            }
        });
    });

    // Fall Check
    Events.on(engine, 'beforeUpdate', () => {
        if(doge.position.y > H + 50) loseGame();
    });


    // --- WIN / LOSS ---
    function winGame() {
        endGame(true, "Success!", "Doge is safe.", "Next Level", "#2ecc71");
    }

    function loseGame() {
        endGame(false, "Oh no!", "The bees got him!", "Try Again", "#e74c3c");
    }

    function endGame(win, title, msg, btnText, color) {
        if(gameOver) return;
        gameOver = true;
        clearInterval(timerInterval);
        
        const modal = document.getElementById('modal');
        const h1 = document.getElementById('modal-title');
        const p = document.getElementById('modal-msg');
        const btn = document.getElementById('modal-btn');
        
        h1.innerText = title;
        h1.style.color = color;
        p.innerText = msg;
        btn.innerText = btnText;
        btn.className = win ? "btn-next" : "btn-retry";
        btn.onclick = win ? nextLevel : retryLevel;
        
        modal.style.display = 'block';
    }

    function nextLevel() {
        currentLevel++;
        if(currentLevel > 3) currentLevel = 1;
        initLevel(currentLevel);
    }
    
    function retryLevel() {
        initLevel(currentLevel);
    }

    // --- EVENT LISTENERS ---
    window.addEventListener('mousedown', startDraw);
    window.addEventListener('mousemove', moveDraw);
    window.addEventListener('mouseup', endDraw);
    window.addEventListener('touchstart', (e) => { e.preventDefault(); startDraw(e); }, {passive: false});
    window.addEventListener('touchmove', (e) => { e.preventDefault(); moveDraw(e); }, {passive: false});
    window.addEventListener('touchend', endDraw);
    
    // Start Game
    initLevel(1);

</script>
</body>
</html>

