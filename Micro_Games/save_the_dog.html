<!DOCTYPE html>
<html>
<head>
    <title>Save the Doge</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'Segoe UI', sans-serif; touch-action: none; user-select: none; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; align-items: center;
        }

        #timer-bar {
            width: 80%; height: 20px; background: rgba(0,0,0,0.2); border-radius: 10px; margin-top: 20px;
            overflow: hidden; display: none;
        }
        #timer-fill {
            width: 100%; height: 100%; background: #f1c40f; transition: width 0.1s linear;
        }

        #message {
            margin-top: 100px; font-size: 40px; font-weight: bold; color: white; 
            text-shadow: 2px 2px 0 #000; display: none; text-align: center;
        }

        #controls {
            position: absolute; bottom: 50px; pointer-events: auto; display: none;
        }

        .btn {
            padding: 15px 40px; font-size: 24px; border: none; border-radius: 30px;
            background: #2ecc71; color: white; font-weight: bold; cursor: pointer;
            box-shadow: 0 5px #27ae60;
        }
        .btn:active { transform: translateY(3px); box-shadow: 0 2px #27ae60; }
        .btn-retry { background: #e74c3c; box-shadow: 0 5px #c0392b; }

        #hint {
            position: absolute; top: 50px; color: #333; font-weight: bold; background: rgba(255,255,255,0.7);
            padding: 5px 15px; border-radius: 20px;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="hint">Level 1: Draw a line to cover the Doge!</div>
        <div id="timer-bar"><div id="timer-fill"></div></div>
        <div id="message">PROTECTED!</div>
        <div id="controls">
            <button class="btn" id="next-btn" onclick="nextLevel()">Next Level</button>
            <button class="btn btn-retry" id="retry-btn" onclick="resetLevel()" style="display:none;">Try Again</button>
        </div>
    </div>

<script>
    // --- PHYSICS ENGINE ---
    const Engine = Matter.Engine,
          Render = Matter.Render,
          Runner = Matter.Runner,
          Composite = Matter.Composite,
          Bodies = Matter.Bodies,
          Body = Matter.Body,
          Events = Matter.Events,
          Vector = Matter.Vector;

    const engine = Engine.create();
    const world = engine.world;

    // Renderer (We disable wireframes to draw our own Emojis)
    const render = Render.create({
        element: document.body,
        engine: engine,
        options: {
            width: window.innerWidth,
            height: window.innerHeight,
            wireframes: false,
            background: 'transparent'
        }
    });

    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

    // --- GAME STATE ---
    let doge;
    let bees = [];
    let lines = [];
    let isDrawing = false;
    let hasStarted = false; // Physics starts after draw
    let gameOver = false;
    let level = 1;
    let timeLeft = 10;
    let timerInterval = null;

    // --- LEVEL DESIGNS ---
    const levels = {
        1: { dog: {x: 0.5, y: 0.8}, hive: {x: 0.5, y: 0.2}, ground: true },
        2: { dog: {x: 0.2, y: 0.6}, hive: {x: 0.8, y: 0.2}, ground: false, platforms: [{x: 0.2, y: 0.7, w: 0.3, h: 0.05}] },
        3: { dog: {x: 0.5, y: 0.9}, hive: {x: 0.5, y: 0.1}, ground: true, walls: [{x: 0.3, y: 0.9, w: 0.05, h: 0.2}, {x: 0.7, y: 0.9, w: 0.05, h: 0.2}] }
    };

    function loadLevel(lvl) {
        Composite.clear(world);
        engine.events = {}; // Clear old events
        bees = [];
        lines = [];
        hasStarted = false;
        gameOver = false;
        timeLeft = 10;
        document.getElementById('timer-bar').style.display = 'none';
        document.getElementById('timer-fill').style.width = '100%';
        document.getElementById('message').style.display = 'none';
        document.getElementById('controls').style.display = 'none';
        document.getElementById('hint').innerText = `Level ${lvl}: Draw a shield!`;

        const data = levels[lvl] || levels[1];
        const w = window.innerWidth;
        const h = window.innerHeight;

        // Boundaries
        const ground = Bodies.rectangle(w/2, h, w, 50, { isStatic: true, render: { fillStyle: '#27ae60' } });
        const leftW = Bodies.rectangle(0, h/2, 50, h, { isStatic: true, render: { visible: false } });
        const rightW = Bodies.rectangle(w, h/2, 50, h, { isStatic: true, render: { visible: false } });
        const topW = Bodies.rectangle(w/2, -500, w, 50, { isStatic: true }); // High ceiling
        
        let worldObjs = [leftW, rightW, topW];
        if(data.ground) worldObjs.push(ground);

        // Platforms
        if(data.platforms) {
            data.platforms.forEach(p => {
                worldObjs.push(Bodies.rectangle(p.x * w, p.y * h, p.w * w, p.h * h, { isStatic: true, render: { fillStyle: '#8e44ad' } }));
            });
        }
        // Walls
        if(data.walls) {
            data.walls.forEach(p => {
                worldObjs.push(Bodies.rectangle(p.x * w, p.y * h, p.w * w, p.h * h, { isStatic: true, render: { fillStyle: '#7f8c8d' } }));
            });
        }

        Composite.add(world, worldObjs);

        // Spawn Doge
        doge = Bodies.circle(data.dog.x * w, data.dog.y * h, 25, {
            restitution: 0.5,
            render: { fillStyle: 'transparent' } // We draw emoji over it
        });
        Composite.add(world, doge);

        // Hive (Visual only for now)
        hivePos = { x: data.hive.x * w, y: data.hive.y * h };
    }

    // --- DRAWING LOGIC ---
    let points = [];
    
    // Listeners
    document.addEventListener('mousedown', startDraw);
    document.addEventListener('mousemove', moveDraw);
    document.addEventListener('mouseup', endDraw);
    document.addEventListener('touchstart', (e) => startDraw(e.touches[0]));
    document.addEventListener('touchmove', (e) => { e.preventDefault(); moveDraw(e.touches[0]); });
    document.addEventListener('touchend', endDraw);

    function startDraw(e) {
        if(hasStarted || gameOver) return;
        isDrawing = true;
        points = [{ x: e.clientX, y: e.clientY }];
    }

    function moveDraw(e) {
        if(!isDrawing) return;
        const last = points[points.length - 1];
        const dist = Math.hypot(e.clientX - last.x, e.clientY - last.y);
        
        // Add point if moved enough
        if(dist > 20) {
            points.push({ x: e.clientX, y: e.clientY });
            
            // Draw visual temporary line
            const ctx = render.context;
            ctx.beginPath();
            ctx.moveTo(last.x, last.y);
            ctx.lineTo(e.clientX, e.clientY);
            ctx.lineWidth = 10;
            ctx.strokeStyle = '#000';
            ctx.stroke();
        }
    }

    function endDraw() {
        if(!isDrawing) return;
        isDrawing = false;
        if(points.length < 2) return;

        // Create Physics Body from points
        const bodyParts = [];
        for(let i=0; i<points.length-1; i++) {
            const p1 = points[i];
            const p2 = points[i+1];
            
            const cx = (p1.x + p2.x) / 2;
            const cy = (p1.y + p2.y) / 2;
            const len = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);

            const rect = Bodies.rectangle(cx, cy, len, 10, {
                angle: angle,
                render: { fillStyle: '#333' },
                friction: 0.5,
                density: 0.002 // Heavy enough to fall
            });
            bodyParts.push(rect);
        }

        // Combine into one body
        const compoundBody = Body.create({
            parts: bodyParts,
            restitution: 0.1
        });

        Composite.add(world, compoundBody);
        
        // Start the game!
        startGameFlow();
    }

    // --- GAMEPLAY LOGIC ---

    function startGameFlow() {
        hasStarted = true;
        document.getElementById('timer-bar').style.display = 'block';

        // Timer
        timerInterval = setInterval(() => {
            if(gameOver) return;
            timeLeft -= 0.1;
            document.getElementById('timer-fill').style.width = (timeLeft * 10) + '%';
            
            if(timeLeft <= 0) {
                winGame();
            }
        }, 100);

        // Spawn Bees Loop
        let beeCount = 0;
        const beeInterval = setInterval(() => {
            if(gameOver || timeLeft <= 0 || beeCount > 15) {
                clearInterval(beeInterval); return;
            }
            spawnBee();
            beeCount++;
        }, 500); // New bee every 0.5s
    }

    function spawnBee() {
        const bee = Bodies.circle(hivePos.x, hivePos.y, 10, {
            frictionAir: 0,
            restitution: 0.8,
            render: { fillStyle: 'transparent' } // Emoji overlay
        });
        
        // Shoot bee towards dog
        const dx = doge.position.x - hivePos.x;
        const dy = doge.position.y - hivePos.y;
        const forceMag = 0.002; // Strength
        
        // Normalize vector
        const len = Math.hypot(dx, dy);
        Body.applyForce(bee, bee.position, { x: (dx/len)*forceMag, y: (dy/len)*forceMag });

        bees.push(bee);
        Composite.add(world, bee);
    }

    // Game Loop (Update Logic)
    Events.on(engine, 'afterUpdate', () => {
        if(gameOver) return;

        // Attract Bees constantly (Homing Missiles)
        bees.forEach(bee => {
            const dx = doge.position.x - bee.position.x;
            const dy = doge.position.y - bee.position.y;
            const len = Math.hypot(dx, dy);
            // Gentle homing force
            Body.applyForce(bee, bee.position, { x: (dx/len)*0.00005, y: (dy/len)*0.00005 });
        });

        // Check Collisions
        // Matter.js collision detection is complex, simple distance check is faster for circles
        for(let bee of bees) {
            const dist = Math.hypot(bee.position.x - doge.position.x, bee.position.y - doge.position.y);
            if(dist < 35) { // Radius 25 + 10
                loseGame();
                break;
            }
        }
        
        // Check Fall off world
        if(doge.position.y > window.innerHeight + 100) loseGame();
    });

    // Custom Rendering (Emojis)
    Events.on(render, 'afterRender', () => {
        const ctx = render.context;
        ctx.font = "40px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // Draw Doge
        ctx.save();
        ctx.translate(doge.position.x, doge.position.y);
        ctx.rotate(doge.angle);
        ctx.fillText(gameOver && timeLeft > 0 ? "ðŸ˜µ" : (timeLeft<=0 ? "ðŸ˜Ž" : "ðŸ¶"), 0, 0);
        ctx.restore();

        // Draw Bees
        ctx.font = "20px Arial";
        bees.forEach(bee => {
            ctx.save();
            ctx.translate(bee.position.x, bee.position.y);
            ctx.fillText("ðŸ", 0, 0);
            ctx.restore();
        });

        // Draw Hive
        ctx.font = "50px Arial";
        ctx.fillText("ðŸª¹", hivePos.x, hivePos.y);
    });

    function winGame() {
        gameOver = true;
        clearInterval(timerInterval);
        document.getElementById('message').innerText = "SAFE!";
        document.getElementById('message').style.color = "#2ecc71";
        document.getElementById('message').style.display = 'block';
        
        document.getElementById('controls').style.display = 'block';
        document.getElementById('next-btn').style.display = 'inline-block';
        document.getElementById('retry-btn').style.display = 'none';
    }

    function loseGame() {
        if(gameOver) return;
        gameOver = true;
        clearInterval(timerInterval);
        document.getElementById('message').innerText = "STUNG!";
        document.getElementById('message').style.color = "#e74c3c";
        document.getElementById('message').style.display = 'block';

        document.getElementById('controls').style.display = 'block';
        document.getElementById('next-btn').style.display = 'none';
        document.getElementById('retry-btn').style.display = 'inline-block';
    }

    function resetLevel() {
        loadLevel(level);
    }
    
    function nextLevel() {
        level++;
        if(level > 3) level = 1; // Loop back
        loadLevel(level);
    }

    // Init
    window.onload = () => loadLevel(1);

</script>
</body>
</html>

