<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Save the Doge (Fixed)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #87CEEB; touch-action: none; user-select: none; font-family: sans-serif; }
        canvas { display: block; width: 100%; height: 100%; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; align-items: center; }
        
        #level-info { margin-top: 20px; font-size: 24px; color: white; font-weight: bold; text-shadow: 2px 2px 0 #000; }
        
        #timer-box { 
            width: 80%; height: 20px; background: rgba(0,0,0,0.3); border: 2px solid white; 
            border-radius: 10px; margin-top: 10px; overflow: hidden; display: none;
        }
        #timer-bar { width: 100%; height: 100%; background: #f1c40f; }

        #hint {
            position: absolute; bottom: 100px; background: white; padding: 10px 20px; 
            border-radius: 20px; font-weight: bold; color: #333; animation: bounce 1.5s infinite;
        }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }

        /* POPUP MODAL */
        #modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: white; padding: 30px; border-radius: 15px; text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); pointer-events: auto; display: none; min-width: 200px;
        }
        button {
            padding: 12px 30px; border: none; border-radius: 25px; font-size: 18px; font-weight: bold;
            color: white; cursor: pointer; margin-top: 15px;
        }
        .btn-win { background: #2ecc71; }
        .btn-lose { background: #e74c3c; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="level-info">Level 1</div>
        <div id="timer-box"><div id="timer-bar"></div></div>
        <div id="hint">ðŸ‘‡ Draw a line to protect him!</div>

        <div id="modal">
            <h2 id="m-title">Game Over</h2>
            <p id="m-msg">...</p>
            <button id="m-btn" onclick="location.reload()">Retry</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    // --- SETUP ENGINE ---
    const Engine = Matter.Engine,
          Runner = Matter.Runner,
          Composite = Matter.Composite,
          Bodies = Matter.Bodies,
          Body = Matter.Body,
          Events = Matter.Events,
          Vector = Matter.Vector;

    const engine = Engine.create();
    const world = engine.world;
    const runner = Runner.create();
    
    // Custom Renderer Setup
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let W, H;
    function resize() {
        W = window.innerWidth;
        H = window.innerHeight;
        canvas.width = W;
        canvas.height = H;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- GAME STATE ---
    let currentLevel = 1;
    let isDrawing = false;
    let hasStarted = false;
    let gameOver = false;
    let points = []; // Drawing points
    let timeLeft = 10;
    
    // Entities
    let doge, hive;
    let bees = [];
    let walls = [];
    let lineBody = null;

    // --- LEVELS ---
    const levels = {
        1: { dog: {x: 0.5, y: 0.75}, hive: {x: 0.5, y: 0.2}, walls: [{x:0.5, y:1.02, w:1, h:0.1}] }, // Ground only
        2: { dog: {x: 0.3, y: 0.6}, hive: {x: 0.8, y: 0.2}, walls: [{x:0.3, y:0.7, w:0.4, h:0.05}] }, // Floating Platform
        3: { dog: {x: 0.5, y: 0.8}, hive: {x: 0.2, y: 0.2}, walls: [{x:0.4, y:0.9, w:0.1, h:0.4}, {x:0.6, y:0.9, w:0.1, h:0.4}, {x:0.5, y:1.02, w:1, h:0.1}] } // Between walls
    };

    function initLevel(lvl) {
        Composite.clear(world);
        engine.events = {}; 
        bees = [];
        walls = [];
        points = [];
        lineBody = null;
        isDrawing = false;
        hasStarted = false;
        gameOver = false;
        timeLeft = 10;

        document.getElementById('modal').style.display = 'none';
        document.getElementById('timer-box').style.display = 'none';
        document.getElementById('hint').style.display = 'block';
        document.getElementById('level-info').innerText = "Level " + lvl;

        const data = levels[lvl] || levels[1];

        // 1. Create Walls
        data.walls.forEach(w => {
            const wall = Bodies.rectangle(w.x * W, w.y * H, w.w * W, w.h * H, { 
                isStatic: true,
                render: { fillStyle: '#27ae60' } // Used for internal tracking
            });
            walls.push(wall);
            Composite.add(world, wall);
        });

        // 2. Create Doge (Initially Static so he doesn't fall)
        doge = Bodies.circle(data.dog.x * W, data.dog.y * H, 25, {
            isStatic: true, // Will change to dynamic later
            label: 'Doge'
        });
        Composite.add(world, doge);

        // 3. Hive Position
        hive = { x: data.hive.x * W, y: data.hive.y * H };
    }

    // --- INPUT (DRAWING) ---
    function getCoords(e) {
        return {
            x: e.touches ? e.touches[0].clientX : e.clientX,
            y: e.touches ? e.touches[0].clientY : e.clientY
        };
    }

    function startDraw(e) {
        if(hasStarted || gameOver) return;
        isDrawing = true;
        points.push(getCoords(e));
    }

    function moveDraw(e) {
        if(!isDrawing) return;
        const pos = getCoords(e);
        const last = points[points.length-1];
        
        // Only add point if distance > 10px (Smoothness)
        if(Math.hypot(pos.x - last.x, pos.y - last.y) > 10) {
            points.push(pos);
        }
    }

    function endDraw() {
        if(!isDrawing) return;
        isDrawing = false;
        
        // Convert line to physics body
        if(points.length > 2) {
            const parts = [];
            for(let i=0; i<points.length-1; i++) {
                const p1 = points[i];
                const p2 = points[i+1];
                const cx = (p1.x + p2.x)/2;
                const cy = (p1.y + p2.y)/2;
                const len = Math.hypot(p2.x-p1.x, p2.y-p1.y);
                const ang = Math.atan2(p2.y-p1.y, p2.x-p1.x);
                
                parts.push(Bodies.rectangle(cx, cy, len, 8, { angle: ang }));
            }
            
            lineBody = Body.create({
                parts: parts,
                restitution: 0.1,
                friction: 0.8,
                density: 0.005
            });
            Composite.add(world, lineBody);
            
            startGame();
        }
    }

    // --- GAME LOGIC ---
    function startGame() {
        hasStarted = true;
        document.getElementById('hint').style.display = 'none';
        document.getElementById('timer-box').style.display = 'block';

        // Unfreeze Doge
        Body.setStatic(doge, false);
        
        // Timer
        const tInt = setInterval(() => {
            if(gameOver) { clearInterval(tInt); return; }
            timeLeft -= 0.1;
            document.getElementById('timer-bar').style.width = (timeLeft * 10) + "%";
            if(timeLeft <= 0) endGame(true);
        }, 100);

        // Spawn Bees
        let beeCount = 0;
        const bInt = setInterval(() => {
            if(gameOver || timeLeft <= 0 || beeCount > 30) { clearInterval(bInt); return; }
            
            const b = Bodies.circle(hive.x, hive.y, 8, { 
                restitution: 0.9, 
                frictionAir: 0,
                label: 'Bee'
            });
            
            // Push towards doge
            const dir = Vector.sub(doge.position, hive);
            Body.applyForce(b, b.position, Vector.mult(Vector.normalise(dir), 0.002));
            
            bees.push(b);
            Composite.add(world, b);
            beeCount++;
        }, 300);
    }

    // --- CUSTOM RENDER LOOP ---
    function draw() {
        ctx.clearRect(0, 0, W, H);

        // 1. Draw Walls
        ctx.fillStyle = "#27ae60";
        walls.forEach(w => {
            ctx.beginPath();
            // Draw rect from center
            const v = w.vertices;
            ctx.moveTo(v[0].x, v[0].y);
            for(let i=1; i<v.length; i++) ctx.lineTo(v[i].x, v[i].y);
            ctx.closePath();
            ctx.fill();
        });

        // 2. Draw Doge
        const dPos = doge.position;
        // Debug circle (visible if emoji fails)
        ctx.fillStyle = "rgba(0,0,0,0.2)";
        ctx.beginPath(); ctx.arc(dPos.x, dPos.y, 25, 0, 6.28); ctx.fill();
        // Emoji
        ctx.font = "40px Arial";
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.save();
        ctx.translate(dPos.x, dPos.y);
        ctx.rotate(doge.angle);
        ctx.fillText(gameOver && timeLeft > 0 ? "ðŸ˜µ" : (timeLeft<=0?"ðŸ˜Ž":"ðŸ¶"), 0, 0);
        ctx.restore();

        // 3. Draw Hive
        ctx.font = "50px Arial";
        ctx.fillText("ðŸª¹", hive.x, hive.y);

        // 4. Draw Bees
        ctx.font = "20px Arial";
        bees.forEach(b => {
            ctx.save();
            ctx.translate(b.position.x, b.position.y);
            ctx.fillText("ðŸ", 0, 0);
            ctx.restore();
            
            // Homing Physics
            if(hasStarted && !gameOver) {
                const dir = Vector.sub(doge.position, b.position);
                Body.applyForce(b, b.position, Vector.mult(Vector.normalise(dir), 0.00004));
            }
        });

        // 5. Draw Player Line
        if(lineBody) {
            ctx.fillStyle = "#000";
            lineBody.parts.forEach(p => {
                ctx.beginPath();
                const v = p.vertices;
                ctx.moveTo(v[0].x, v[0].y);
                for(let i=1; i<v.length; i++) ctx.lineTo(v[i].x, v[i].y);
                ctx.fill();
            });
        }
        
        // 6. Draw Current Drawing Stroke (Before physics)
        if(isDrawing && points.length > 1) {
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';
            ctx.strokeStyle = "#000";
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for(let i=1; i<points.length; i++) ctx.lineTo(points[i].x, points[i].y);
            ctx.stroke();
        }

        requestAnimationFrame(draw);
    }

    // --- COLLISION & ENDING ---
    Events.on(engine, 'collisionStart', evt => {
        if(gameOver) return;
        evt.pairs.forEach(p => {
            const A = p.bodyA.label, B = p.bodyB.label;
            if((A==='Doge' && B==='Bee') || (B==='Doge' && A==='Bee')) endGame(false);
        });
    });

    Events.on(engine, 'beforeUpdate', () => {
        if(!gameOver && doge.position.y > H+50) endGame(false);
    });

    function endGame(win) {
        gameOver = true;
        const m = document.getElementById('modal');
        const t = document.getElementById('m-title');
        const msg = document.getElementById('m-msg');
        const btn = document.getElementById('m-btn');
        
        m.style.display = 'block';
        if(win) {
            t.innerText = "SAFE!"; t.style.color = "#2ecc71";
            msg.innerText = "Doge survived.";
            btn.innerText = "Next Level";
            btn.className = "btn-win";
            btn.onclick = () => { currentLevel++; if(currentLevel>3) currentLevel=1; initLevel(currentLevel); };
        } else {
            t.innerText = "STUNG!"; t.style.color = "#e74c3c";
            msg.innerText = "The bees got him.";
            btn.innerText = "Retry";
            btn.className = "btn-lose";
            btn.onclick = () => initLevel(currentLevel);
        }
    }

    // --- EVENT LISTENERS ---
    window.addEventListener('mousedown', startDraw);
    window.addEventListener('mousemove', moveDraw);
    window.addEventListener('mouseup', endDraw);
    window.addEventListener('touchstart', (e)=>{e.preventDefault(); startDraw(e)}, {passive:false});
    window.addEventListener('touchmove', (e)=>{e.preventDefault(); moveDraw(e)}, {passive:false});
    window.addEventListener('touchend', endDraw);

    // START
    Runner.run(runner, engine);
    initLevel(1);
    draw(); // Start Render Loop

</script>
</body>
</html>

